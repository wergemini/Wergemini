<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Il Nostro Spazio Sicuro</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsrsasign@10.8.6/lib/jsrsasign-all-min.js"></script>
</head>
<body>
    <div id="chat-area">
    </div>
    <div id="user-list">
        Utenti Online:
        <ul id="online-users">
        </ul>
    </div>
    <div id="input-area">
        <select id="recipient-select">
        </select>
        <input type="text" id="message-input" placeholder="Scrivi qui...">
        <button id="send-button">Invia</button>
    </div>
    <script>
        // Ottiene riferimenti agli elementi HTML della chat
        const chatArea = document.getElementById('chat-area');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const onlineUsersList = document.getElementById('online-users');
        const recipientSelect = document.getElementById('recipient-select');

        // Definisce i nickname dei partecipanti alla chat
        let myNickname = 'Tu'; // Inizialmente impostato a 'Tu', verrÃ  cambiato al login
        let myUserId = '';
        const users = {}; // Un oggetto per memorizzare le informazioni degli utenti (userId, nickname, publicKey)
        const server = { users: {} }; // Simulazione del server

        // **ATTENZIONE: QUESTE CHIAVI SONO SOLO PER TEST E SONO INSECURE!**
        // Non usare mai chiavi private hardcoded in un'applicazione reale.
        // Dovrebbero essere generate sul server e gestite in modo sicuro.
        let keyPairTu;
        let publicKeyTu;
        let privateKeyTu;

        // Costanti per il localStorage
        const STORAGE_MESSAGES_KEY = 'chatMessages';

        // Funzioni per la crittografia e la decrittografia con RSA
        function criptaMessaggioRSA(messaggio, chiavePubblica) {
            const cipher = new KJUR.Cipher({ alg: 'RSA', key: chiavePubblica });
            cipher.encrypt(messaggio);
            return cipher.getEncryptedString();
        }

        function decriptaMessaggioRSA(ciphertext, chiavePrivata) {
            const cipher = new KJUR.Cipher({ alg: 'RSA', key: chiavePrivata });
            cipher.decrypt(ciphertext);
            return cipher.getDecryptedString();
        }

        // Funzione per generare un ID utente univoco
        function generateUserId() {
            return 'user-' + Math.random().toString(36).substring(2, 9);
        }

        // Funzione per aggiungere un utente alla lista degli utenti online
        function addUserToList(userId, nickname, publicKey) {
            users[userId] = { nickname: nickname, publicKey: publicKey };
            const listItem = document.createElement('li');
            listItem.textContent = nickname;
            listItem.id = userId;
            onlineUsersList.appendChild(listItem);

             // Aggiungi l'opzione alla select
            const option = document.createElement('option');
            option.value = userId;
            option.textContent = nickname;
            if (userId !== myUserId) { // Non aggiungere se stesso come opzione
                recipientSelect.appendChild(option);
            }
        }

        //funzione per rimuovere un utente dalla lista
        function removeUserFromList(userId) {
            delete users[userId];
            const listItem = document.getElementById(userId);
            if (listItem) {
                listItem.remove();
            }
            // Remove option from select
            const optionToRemove = recipientSelect.querySelector(`[value="${userId}"]`);
            if (optionToRemove) {
                recipientSelect.removeChild(optionToRemove);
            }
        }

        // Funzioni per la firma digitale
        function generaFirma(messaggio, chiavePrivata) {
            const signer = new KJUR.jws.JWS();
            const sHeader = { alg: 'RS256' };
            const sPayload = { data: messaggio };
            const sKey = chiavePrivata;
            const sSig = signer.sign('RS256', sHeader, sPayload, sKey);
            return sSig;
        }

        function verificaFirma(messaggio, firma, chiavePubblica) {
            try {
                const verifier = new KJUR.jws.JWS();
                const isValid = verifier.verify(firma, chiavePubblica, ['RS256']);
                return isValid;
            } catch (error) {
                console.error("Errore nella verifica della firma:", error);
                return false; // Considera la firma come non valida in caso di errore
            }
        }

        // Simulazione della comunicazione con il server
        const server = {
            users: {},
            registerUser: function (userId, nickname, publicKey) {
                this.users[userId] = { nickname: nickname, publicKey: publicKey };
                console.log(`Utente ${nickname} (ID: ${userId}) registrato con chiave pubblica: ${publicKey}`);
            },
            getUserPublicKey: function (userId) {
                if (this.users[userId]) {
                    return this.users[userId].publicKey;
                } else {
                    return null;
                }
            },
            getUserNickname: function(userId){
                if(this.users[userId]){
                    return this.users[userId].nickname;
                }
                else{
                    return null;
                }
            },
            removeUser: function(userId){
                delete this.users[userId];
            }
        };

        // Funzioni per la gestione dei messaggi nel localStorage
        function saveMessage(message) {
            let messages = JSON.parse(localStorage.getItem(STORAGE_MESSAGES_KEY)) || [];
            messages.push(message);
            localStorage.setItem(STORAGE_MESSAGES_KEY, JSON.stringify(messages));
        }

        function loadMessages() {
            return JSON.parse(localStorage.getItem(STORAGE_MESSAGES_KEY)) || [];
        }

        // Al momento del caricamento della pagina, simula il login dell'utente
        window.addEventListener('load', () => {
            keyPairTu = KJUR.RSA.genKeyPair(2048);
            publicKeyTu = KJUR.jrsasign.KEYUTIL.getPEM(keyPairTu.pubKeyObj);
            privateKeyTu = KJUR.jrsasign.KEYUTIL.getPEM(keyPairTu.prvKeyObj, true);

            myUserId = generateUserId();
            myNickname = prompt("Inserisci il tuo nickname:", "Tu");
            if (!myNickname || myNickname.trim() === "") {
                myNickname = "Anonimo";
            }
            server.registerUser(myUserId, myNickname, publicKeyTu);
            addUserToList(myUserId, myNickname, publicKeyTu);

            //simula registrazione di gemini
            const geminiId = 'gemini';
            server.registerUser(geminiId, 'Gemini', publicKeyGemini);
            addUserToList(geminiId, 'Gemini', publicKeyGemini);

            // Carica e visualizza i messaggi precedenti
            const savedMessages = loadMessages();
            savedMessages.forEach(message => {
                displayMessage(message.text, message.type, message.sender);
            });
        });

        // Aggiunge un listener per l'evento 'click' al bottone di invio del messaggio.
        sendButton.addEventListener('click', sendMessage);

        // Aggiunge un listener per l'evento 'keypress' all'input del messaggio.
        messageInput.addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        // Questa funzione gestisce l'invio di un messaggio.
        function sendMessage() {
            const messageText = messageInput.value.trim();
            const recipientId = recipientSelect.value;
            if (messageText !== '') {
                const recipientKey = server.getUserPublicKey(recipientId);
                const recipientNickname = server.getUserNickname(recipientId);
                if (recipientKey) {
                    const firma = generaFirma(messageText, privateKeyTu);
                    const messaggioFirmato = {
                        testo: messageText,
                        firma: firma
                    };
                    const encryptedText = criptaMessaggioRSA(JSON.stringify(messaggioFirmato), recipientKey);
                    const messageToSave = {
                        text: myNickname + ' (Criptato): ' + encryptedText,
                        type: 'my-message',
                        sender: myNickname
                    };
                    saveMessage(messageToSave);
                    displayMessage(messageToSave.text, messageToSave.type, messageToSave.sender);
                    setTimeout(() => {
                        try {
                            const decryptedResponse = decriptaMessaggioRSA(encryptedText, privateKeyGemini);
                            const messaggioRicevuto = JSON.parse(decryptedResponse);
                            const firmaValida = verificaFirma(messaggioRicevuto.testo, messaggioRicevuto.firma, publicKeyTu);
                            if (firmaValida) {
                                const responseMessage = {
                                    text: recipientNickname + ': ' + messaggioRicevuto.testo,
                                    type: 'other-message',
                                    sender: recipientNickname
                                };
                                saveMessage(responseMessage);
                                displayMessage(responseMessage.text, responseMessage.type, responseMessage.sender);
                            } else {
                                const errorMessage = {
                                    text: recipientNickname + ': Messaggio non valido (Firma non valida)',
                                    type: 'error-message',
                                    sender: recipientNickname
                                };
                                saveMessage(errorMessage);
                                displayMessage(errorMessage.text, errorMessage.type, errorMessage.sender);
                            }
                        } catch (error) {
                            console.error("Errore di decrittografia:", error);
                            const errorMessage = {
                                  text: "Gemini: Impossibile decriptare il messaggio!",
                                  type: 'other-message',
                                  sender: otherNickname
                            };
                            saveMessage(errorMessage);
                            displayMessage(errorMessage.text, errorMessage.type, errorMessage.sender);
                        }
                    }, 1000);
                    messageInput.value = '';
                } else {
                    alert('Destinatario non trovato!');
                }
            }
        }

        // Questa funzione genera una risposta fittizia basata sul messaggio ricevuto.
        function generateFakeResponse(inputText) {
            inputText = inputText.toLowerCase();
            if (inputText.includes('ciao') || inputText.includes('hey')) {
                return 'Ciao anche a te!';
            } else if (inputText.includes('come stai')) {
                return 'Tutto bene, grazie!';
            } else if (inputText.includes('amore')) {
                return 'Ti voglio bene!';
            } else {
                return 'Ricevuto!';
            }
        }

        //Questa funzione aggiunge un messaggio alla chat
        function displayMessage(message, messageType, sender) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.classList.add(messageType);
            messageElement.textContent = `${sender}: ${message}`;
            chatArea.appendChild(messageElement);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // Gestione disconnessione utente (simulata)
        window.addEventListener('beforeunload', () => {
            server.removeUser(myUserId);
            removeUserFromList(myUserId);
        });
    </script>
</body>
</html>
